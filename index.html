<!-- 
Disclaimer:
The text included in this document, originating from TypeScript documentation or related sources, 
is used solely for illustrative and placeholder purposes. 
It is not intended to convey any proprietary or authoritative information about TypeScript. 
All rights and ownership of the original text belong to its respective authors and copyright holders. 
For official information, please refer to the TypeScript documentation. 
https://www.typescriptlang.org/docs/handbook/2/basic-types.html
-->

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="icon" type="image/png" href="assets/favicon.png" />

    <title>Technical Documentation</title>

    <link rel="stylesheet" type="text/css" href="styles/style.css" />
    <link
      rel="stylesheet"
      href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200&icon_names=search"
    />
  </head>
  <body>
    <header>
      <div id="top-navbar">
        <div class="search-container">
          <button type="submit">
            <span class="material-symbols-outlined">search</span>
          </button>
          <input type="text" placeholder="Search" name="search" />
        </div>
      </div>
    </header>

    <main id="main-doc">
      <nav id="side-navbar">
        <h2>TypeScript Documentation</h2>
        <ul>
          <a href="#Introduction" class="nav-link"><li>Introduction</li></a>
          <a href="#Static_type-checking" class="nav-link"
            ><li>Static type-checking</li></a
          >
          <a href="#Non-expection_Failures" class="nav-link"
            ><li>Non-exception Failures</li></a
          >
          <a href="#Types_for_Tooling" class="nav-link"
            ><li>Types for Tooling</li></a
          >
          <a href="#Emitting_with_Errors" class="nav-link"
            ><li>Emitting with Errors</li></a
          >
        </ul>
      </nav>
      <article>
        <h1>The Basics</h1>

        <section class="main-section" id="Introduction">
          <h2>Introduction</h2>

          <p>
            Each and every value in JavaScript has a set of behaviors you can
            observe from running different operations. That sounds abstract, but
            as a quick example, consider some operations we might run on a
            variable named message.
          </p>

          <div class="code-wrapper">
            <div class="code-color">
              <code>
                <div>
                  <span style="color: var(--code-comment)"
                    >// Accessing the property 'toLowerCase'</span
                  >
                </div>
                <div>
                  <span style="color: var(--code-comment)"
                    >// on 'message' and then calling it</span
                  >
                </div>
                <div>
                  <span style="color: var(--code-variable)">message</span
                  ><span>.</span
                  ><span style="color: var(--code-property)">toLowerCase</span
                  ><span>();</span>
                </div>
                <div>
                  <span style="color: var(--code-comment)"
                    >// Calling 'message'</span
                  >
                </div>
                <div>
                  <span style="color: var(--code-property)">message</span
                  ><span>();</span>
                </div>
              </code>
            </div>
          </div>

          <p>
            If we break this down, the first runnable line of code accesses a
            property called toLowerCase and then calls it. The second one tries
            to call message directly.
          </p>

          <p>
            But assuming we don’t know the value of message - and that’s pretty
            common - we can’t reliably say what results we’ll get from trying to
            run any of this code. The behavior of each operation depends
            entirely on what value we had in the first place.
          </p>

          <ul>
            <li>Is message callable?</li>
            <li>Does it have a property called toLowerCase on it?</li>
            <li>If it does, is toLowerCase even callable?</li>
            <li>If both of these values are callable, what do they return?</li>
          </ul>

          <p>
            The answers to these questions are usually things we keep in our
            heads when we write JavaScript, and we have to hope we got all the
            details right.
          </p>

          <p>Let’s say message was defined in the following way.</p>

          <div class="code-wrapper">
            <div class="code-color">
              <code>
                <div>
                  <span style="color: var(--code-declaration)">const</span>
                  <span style="color: var(--code-variable)">message</span>
                  <span> = </span>
                  <span style="color: var(--code-string)">"Hello World!"</span
                  ><span>;</span>
                </div>
              </code>
            </div>
          </div>

          <p>
            As you can probably guess, if we try to run message.toLowerCase(),
            we’ll get the same string only in lower-case.
          </p>

          <p>
            What about that second line of code? If you’re familiar with
            JavaScript, you’ll know this fails with an exception:
          </p>

          <div class="code-wrapper">
            <div class="code-color">
              <code>
                <div><span>TypeError: message is not a function </span></div>
              </code>
            </div>
          </div>

          <p>It’d be great if we could avoid mistakes like this.</p>

          <p>
            When we run our code, the way that our JavaScript runtime chooses
            what to do is by figuring out the type of the value - what sorts of
            behaviors and capabilities it has. That’s part of what that
            TypeError is alluding to - it’s saying that the string "Hello
            World!" cannot be called as a function.
          </p>

          <p>
            For some values, such as the primitives string and number, we can
            identify their type at runtime using the typeof operator. But for
            other things like functions, there’s no corresponding runtime
            mechanism to identify their types. For example, consider this
            function:
          </p>

          <div class="code-wrapper">
            <div class="code-color">
              <code>
                <div>
                  <span style="color: var(--code-declaration)">function</span
                  ><span style="color: var(--code-property)"> fn</span
                  ><span>(</span
                  ><span style="color: var(--code-declaration)">x</span
                  ><span>) {</span>
                </div>
                <div>
                  <span>&nbsp</span
                  ><span style="color: var(--code-return)"> return</span
                  ><span style="color: var(--code-declaration)"> x</span
                  ><span>.</span
                  ><span style="color: var(--code-property)">flip</span
                  ><span>();</span>
                </div>
                <div><span> }</span></div>
              </code>
            </div>
          </div>

          <p>
            We can observe by reading the code that this function will only work
            if given an object with a callable flip property, but JavaScript
            doesn’t surface this information in a way that we can check while
            the code is running. The only way in pure JavaScript to tell what fn
            does with a particular value is to call it and see what happens.
            This kind of behavior makes it hard to predict what the code will do
            before it runs, which means it’s harder to know what your code is
            going to do while you’re writing it.
          </p>

          <p>
            Seen in this way, a type is the concept of describing which values
            can be passed to fn and which will crash. JavaScript only truly
            provides dynamic typing - running the code to see what happens.
          </p>

          <p>
            The alternative is to use a static type system to make predictions
            about what the code is expected to do before it runs.
          </p>
        </section>
        <section class="main-section" id="Static_type-checking">
          <h2>Static type-checking</h2>

          <p>
            Think back to that TypeError we got earlier from trying to call a
            string as a function. Most people don’t like to get any sorts of
            errors when running their code - those are considered bugs! And when
            we write new code, we try our best to avoid introducing new bugs.
          </p>

          <p>
            If we add just a bit of code, save our file, re-run the code, and
            immediately see the error, we might be able to isolate the problem
            quickly; but that’s not always the case. We might not have tested
            the feature thoroughly enough, so we might never actually run into a
            potential error that would be thrown! Or if we were lucky enough to
            witness the error, we might have ended up doing large refactorings
            and adding a lot of different code that we’re forced to dig through.
          </p>

          <p>
            Ideally, we could have a tool that helps us find these bugs before
            our code runs. That’s what a static type-checker like TypeScript
            does. Static types systems describe the shapes and behaviors of what
            our values will be when we run our programs. A type-checker like
            TypeScript uses that information and tells us when things might be
            going off the rails.
          </p>

          <div class="code-wrapper">
            <div class="code-color">
              <code>
                <div>
                  <span style="color: var(--code-declaration)">const</span
                  ><span style="color: var(--code-variable)"> message</span
                  ><span> = </span
                  ><span style="color: var(--code-string)">"hello!"</span
                  ><span>;</span>
                </div>
                <div>
                  <span
                    style="
                      color: var(--code-property);
                      text-decoration: underline;
                      text-decoration-style: wavy;
                      text-decoration-color: #9e2828a4;
                      text-underline-offset: 3px;
                    "
                    >message</span
                  ><span>();</span>
                </div>
                <div class="code-error">
                  <span>This expression is not callable.</span>
                </div>
                <div></div>
                <div class="code-error">
                  <span>Type 'String' has no call signatures.</span>
                </div>
              </code>
            </div>
          </div>
        </section>
        <section class="main-section" id="Non-expection_Failures">
          <h2>Non-exception Failures</h2>

          <p>
            So far we’ve been discussing certain things like runtime errors -
            cases where the JavaScript runtime tells us that it thinks something
            is nonsensical. Those cases come up because the ECMAScript
            specification has explicit instructions on how the language should
            behave when it runs into something unexpected.
          </p>

          <p>
            For example, the specification says that trying to call something
            that isn’t callable should throw an error. Maybe that sounds like
            “obvious behavior”, but you could imagine that accessing a property
            that doesn’t exist on an object should throw an error too. Instead,
            JavaScript gives us different behavior and returns the value
            undefined:
          </p>

          <p>
            Ultimately, a static type system has to make the call over what code
            should be flagged as an error in its system, even if it’s “valid”
            JavaScript that won’t immediately throw an error. In TypeScript, the
            following code produces an error about location not being defined:
          </p>

          <p>
            While sometimes that implies a trade-off in what you can express,
            the intent is to catch legitimate bugs in our programs. And
            TypeScript catches a lot of legitimate bugs.
          </p>
        </section>
        <section class="main-section" id="Types_for_Tooling">
          <h2>Types for Tooling</h2>

          <p>
            TypeScript can catch bugs when we make mistakes in our code. That’s
            great, but TypeScript can also prevent us from making those mistakes
            in the first place.
          </p>

          <p>
            The type-checker has information to check things like whether we’re
            accessing the right properties on variables and other properties.
            Once it has that information, it can also start suggesting which
            properties you might want to use.
          </p>

          <p>
            That means TypeScript can be leveraged for editing code too, and the
            core type-checker can provide error messages and code completion as
            you type in the editor. That’s part of what people often refer to
            when they talk about tooling in TypeScript.
          </p>

          <p>
            TypeScript takes tooling seriously, and that goes beyond completions
            and errors as you type. An editor that supports TypeScript can
            deliver “quick fixes” to automatically fix errors, refactorings to
            easily re-organize code, and useful navigation features for jumping
            to definitions of a variable, or finding all references to a given
            variable. All of this is built on top of the type-checker and is
            fully cross-platform, so it’s likely that your favorite editor has
            TypeScript support available.
          </p>
        </section>
        <section class="main-section" id="Emitting_with_Errors">
          <h2>Emitting with Errors</h2>

          <p>
            One thing you might not have noticed from the last example was that
            our hello.js file changed again. If we open that file up then we’ll
            see that the contents still basically look the same as our input
            file. That might be a bit surprising given the fact that tsc
            reported an error about our code, but this is based on one of
            TypeScript’s core values: much of the time, you will know better
            than TypeScript.
          </p>

          <p>
            To reiterate from earlier, type-checking code limits the sorts of
            programs you can run, and so there’s a tradeoff on what sorts of
            things a type-checker finds acceptable. Most of the time that’s
            okay, but there are scenarios where those checks get in the way. For
            example, imagine yourself migrating JavaScript code over to
            TypeScript and introducing type-checking errors. Eventually you’ll
            get around to cleaning things up for the type-checker, but that
            original JavaScript code was already working! Why should converting
            it over to TypeScript stop you from running it?
          </p>

          <p>
            So TypeScript doesn’t get in your way. Of course, over time, you may
            want to be a bit more defensive against mistakes, and make
            TypeScript act a bit more strictly. In that case, you can use the
            noEmitOnError compiler option. Try changing your hello.ts file and
            running tsc with that flag:
          </p>
        </section>
      </article>
      <footer class="footer">
        <div class="footer-container">
          <p>
            The text included in this document, originating from TypeScript
            documentation or related sources, is used solely for illustrative
            and placeholder purposes. It is not intended to convey any
            proprietary or authoritative information about TypeScript. All
            rights and ownership of the original text belong to its respective
            authors and copyright holders. For official information, please
            refer to the
            <a
              href="https://www.typescriptlang.org/docs/handbook/2/basic-types.html"
              target="_blank"
              >TypeScript documentation.</a
            >
          </p>
        </div>
      </footer>
    </main>

    <script src="scripts/script.js"></script>
  </body>
</html>
